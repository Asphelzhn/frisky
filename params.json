{"google":"","name":"Frisky","tagline":"A playful scm mirror platform for MSR (mining software repositories)","body":"frisky\r\n======\r\n\r\nA playful scm mirror platform for MSR (mining software repositories)\r\n\r\n[![Build Status](https://secure.travis-ci.org/heelhook/frisky.png?branch=development)](https://travis-ci.org/heelhook/frisky)\r\n\r\n## What this is\r\n\r\nFrisky is an engine to cache and process SCM repositories, supporting initially Git and particularly Github\r\nas a discovery source.\r\n\r\n## How it works\r\n\r\nFrisky allows you to create classifiers that mine information from software repositories, handling the specifics of\r\ndata gathering, caching and storage. Classifiers can interact with each others' data by consuming and setting objects' tags.\r\n\r\nClassifiers are Ruby classes that respond to mining events.\r\n\r\n```\r\nclass CommitCountClassifier << Classifier\r\n  commit :update_commit_count, if: lambda {|commit| commit.files_type('Ruby').any? }\r\n\r\n  def update_file_loc(commit)\r\n    @repository.increment(:commit_count, 1)\r\n  end\r\nend\r\n```\r\n\r\nThe `commit` class method specifies a callback method that will be called whenever a new commit\r\nthat contains at least one file of `Ruby` code.\r\n\r\n### A more useful classifier\r\n\r\nThe following classifier will run `reek` on ruby files on each commit, gathering\r\nthe results on each commit object to get a clear picture of the evolution of code smells\r\non each commit.\r\n\r\nWe also want to persist this information to the committer responsible for the delta so\r\nwe can find out how each user has performed over time.\r\n\r\n\r\n```\r\nclass ReekClassifier << Classifier\r\n  commit :run_reek_on_commit\r\n\r\n  def run_reek_on_commit(commit)\r\n    commit.file_types 'Ruby' do |file|\r\n      # Only get reek when we have something to compare against\r\n      next unless commit.parent\r\n\r\n      reek_v2 = file_reek_on commit.id, file\r\n      reek_v1 = file_reek_on commit.parent.id, file\r\n      reek_delta = reek_v2 - reek_v1\r\n\r\n      commit.increment(:reek, reek_delta)\r\n      commit.author.increment(:reek, reek_delta)\r\n    end\r\n  end\r\n\r\n  def file_reek_on(commit_id, file_path)\r\n    cached_output :reek, commit_id, file_path\r\n  end\r\n\r\n  # Get reek output for an IO\r\n  def output_reek(io)\r\n    # ...\r\n  end\r\nend\r\n\r\n```\r\n\r\nHere the method `file_reek_on` is called to gather the `reek` score of each file on each commit,\r\ngathering the score of the parent of that file and storing the delta associated to the commit and to the author.\r\n\r\nThe method `cached_output` will call `output_reek` only when the score hasn't been generated\r\npreviously.\r\n\r\n## Setup\r\n\r\nFrisky's architecture is composed of `schedulers` and classifiers.\r\n\r\n### Infrastructure requirements\r\n\r\nFrisky requires the following software stack to run\r\n\r\n  - mongodb >= 2.2\r\n  - redis >= 1.4\r\n  - ruby 1.9\r\n\r\n### Installing\r\n\r\nA simple `clone` will do:\r\n\r\n```\r\ngit clone https://github.com/heelhook/frisky.git\r\ncd frisky\r\nbundle install\r\n```\r\n\r\n### Configuring\r\n\r\nThe main configuration file is `frisky.yml`\r\n\r\n```\r\ngithub:\r\n  keys:\r\n    - client_id:client_secret\r\nmongo: mongodb://127.0.0.1/frisky\r\nredis: 127.0.0.1\r\n```\r\n\r\nThe configuration is self-explanatory, the only thing that needs clarification is the `github.keys` key,\r\nthe key is an array of `client_id:client_secret` duples, on startup frisky will pick a random key and use it\r\nthroughout the session.\r\n\r\n### Running\r\n\r\n```\r\nbundle exec bin/frisky-event-scheduler -v\r\n```\r\n\r\nFetches github public events and caches them for further processing. Can be run in parallel in multiple hosts.\r\n\r\n```\r\nbundle exec bin/frisky-classifiers -v\r\n```\r\n\r\nLoads classifiers models and processes events through them. Can be run in parallel in multiple hosts.\r\n","note":"Don't delete this file! It's used internally to help with page regeneration."}